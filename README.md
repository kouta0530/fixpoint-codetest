# fixpoint code test

## はじめに

ここでは、下記の点について説明する

- 実行方法
- 変数、メソッド名の解説
- 問ごとの処理の概要

細かい差分や処理の説明はコードごとのコメントに記載する
問ごとの結果については result.txt を参照

## 実行方法

```
python3 ファイル名.py
```

## 解説

### Q1

#### methods

- 新規
  | メソッド名 | 説明 |
  | ------------------------------------------ | --------------------------------------------------- |
  | convertLogToDateTime(log: str) -> datetime | 確認日時を dateTime 型に変換する |
  | getLog(path: str) -> hash | path を読み込み、サーバーごとのログの辞書配列を返す |

#### models

```
malFunctionLog: dict

key:サーバーアドレス
value:list [datetime,'start'or'fixed']

```

サーバーごとの故障時、故障回復時の種類と確認日時が挿入される

| 状態  | 説明                     |
| ----- | ------------------------ |
| start | 故障が発生したことを示す |
| fixed | 故障が回復したことを示す |

```
hashLog: dict

key: サーバーアドレス
value: [確認日時,応答結果]

```

サーバーごとの応答データをまとめる

#### flow

ログの故障判定

```
tmp 故障開始時のログを保存する変数
```

処理

1. ログを読み込む
2. ログの応答結果が'-'のとき、ログを tmp に退避する
3. tmp にログがあり、応答結果が'-'でないログが現れたとき、  
   アドレスと退避したログの確認日時、'-'でないログの確認日時を出力する
4. 1.~3.をサーバーの数分繰り返す

### Q2

#### methods

- 新規  
  なし

* 追加
  | メソッド名 | 説明 |
  | -------------------- | ----------------------------------------------------------------------- |
  | main(path: str, N=1) | 応答結果が"-"が N 回起きたとき、故障であることを示すパラメータ N の追加 |

### Q3

#### methods

- 新規
  | メソッド名 | 説明 |
  | ------------------------------------------------------------------- | ------------------------------------------------------------------------ |
  | checkOverAvarageResponseTime(m: int, t: int, timelog: list) -> bool | サーバーのログ全ログまたは m 個の平均応答時間が t を超えているか判定する |

- 追加
  | メソッド名 | 説明 |
  | ---------------------------- | --------------------------------------------------------- |
  | main(path: str, N=1,m=1,t=0) | checkverAvarageResponseTime に必要なパラメータ m,t の追加 |

#### models

```
timelog: list[int]
```

サーバーごとの応答時間を格納する

#### flow

各サーバーの平均応答時間の計測と過負荷状態の確認

```
timelog: []
m 直近から遡るログ数
t 基準応答時間
```

前提

- 応答結果が"-"のログは無視する

処理

1. ログの応答結果を timelog に格納する
2. m または timelog の数分の応答時間を取り出し、平均を求める
3. 2.で求めた平均応答時間が t を越えているか判定する

### Q4

#### methods

- 新規
  | メソッド名 | 説明 |
  | ---------------------------- | --------------------------------------------------------- |
  | getSubNetWork(address: str) -> (str, list) | サーバーアドレスのサブネットを求める |
  | checkSubNetworkFailer(servers: list, malFunctionLog: list) -> list| サブネット内のサーバーが故障しているか判定する|

* 追加
  | メソッド名 | 説明 |
  | ---------------------------- | --------------------------------------------------------- |
  | getLog(path: str) -> (dict, dict) | サーバーアドレスをサブネットごとにまとめる機能を追加 |

#### models

```
network: dict

key: サブネット
value: [配下のサーバーアドレス]
```

```
malDurationList:[サブネットマスクの故障時の確認日時、サブネットマスクの故障回復時の確認日時]
```

スイッチ配下のサーバーがすべて故障している期間がある時、故障時、回復時の確認日時が挿入される  
リストが空のとき、サブネットは故障していないことを示す。

#### flow

サブネットごとの故障期間の判定

```
malFunctionLog = { サーバーのアドレス: [確認日時,状態]}
malServerNums: サーバーの故障数
```

前提

- 各サーバーは start -> fix の順でログが記録される
- 各サーバーは故障から回復したときログに開始日時、終了日時が記録される

処理

1. サブネットごとの故障ログを確認日時順にまとめる
2. ログの状態が start のとき、サーバーの故障数を追加する。false のとき、故障数を減らす。
3. 故障数がサブネット配下のサーバー数と同じになった時、故障開始日時を記録する。
   ログの状態が"fix"かつ故障数がサブネット配下のサーバー数と同じ時、故障終了日時を記録する
4. 故障期間を記録する

例

ある２個のサーバーをもつサブネットの故障を確認する

例 1.

```

1 start
2 fix
3 start
4 fix

```

start->fix のため、各サーバーは同時に故障していないため、  
サブネットは故障していない

例 2.

```

1 start
2 start
3 fix
4 fix

```

各サーバーは start -> fix の順でログを記録するため、2 では別のサーバーが故障している。  
そのため、2 の段階でサーバーは 2 台故障した日時=サブネットの故障開始日時を記録する  
3 の段階でサーバーは故障から回復するため、故障終了日時を記録しサブネットの故障期間を記録する
